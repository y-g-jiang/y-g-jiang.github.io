function L(u){const[[e,s,t],[l,a,i],[n,f,M]]=u,w=e*(a*M-i*f)-s*(l*M-i*n)+t*(l*f-a*n);if(Math.abs(w)<1e-10)return null;const c=1/w;return[[(a*M-i*f)*c,(t*f-s*M)*c,(s*i-t*a)*c],[(i*n-l*M)*c,(e*M-t*n)*c,(t*l-e*i)*c],[(l*f-a*n)*c,(s*n-e*f)*c,(e*a-s*l)*c]]}function k(u,e){const s=[[0,0,0],[0,0,0],[0,0,0]];for(let t=0;t<3;t++)for(let l=0;l<3;l++)for(let a=0;a<3;a++)s[t][l]+=u[t][a]*e[a][l];return s}let I=null;async function G(){if(!I)try{const t=(await import("./joraw-DBDL-TL5.js")).default;if(typeof t!="function")throw console.error("JoRaw import error:",t),new Error("JoRaw WASM import is not a function. Check your path or build flags.");const l=new URL("/assets/joraw-BUh50ws_.wasm",import.meta.url).href;I=t({locateFile:(a,i)=>a.endsWith("joraw.wasm")?l:i+a})}catch(s){throw console.error("Failed to load joraw.js:",s),s}const u=await I,e=u.LibRaw||u.JoRaw;if(!e)throw new Error("JoRaw class (or underlying LibRaw) not found in WASM module. Check EMSCRIPTEN_BINDINGS.");return e}const D=[[3.2404542,-1.5371385,-.4985314],[-.969266,1.8760108,.041556],[.0556434,-.2040259,1.0572252]],g=u=>u<=.0031308?12.92*u:1.055*Math.pow(u,1/2.4)-.055;async function J(u,e){const s=await G(),t=new s;try{const l=new Uint8Array(u.slice(0));let a=!1,i=[];if(e.customMatrix&&e.customMatrix.length===9){const o=[[e.customMatrix[0],e.customMatrix[1],e.customMatrix[2]],[e.customMatrix[3],e.customMatrix[4],e.customMatrix[5]],[e.customMatrix[6],e.customMatrix[7],e.customMatrix[8]]],r=L(o);if(r){const y=e.wbGains?e.wbGains[0]:1,h=e.wbGains?e.wbGains[1]:1,R=k(r,[[y,0,0],[0,1,0],[0,0,h]]),d=k(D,R);i=[d[0][0],d[0][1],d[0][2],d[1][0],d[1][1],d[1][2],d[2][0],d[2][1],d[2][2]],a=!0}else throw new Error("Custom Matrix is not invertible (determinant is zero). Please check your values.")}const n={outputBps:16,noAutoBright:!0,bright:a?1:Math.pow(2,e.exposure)};e.blackLevel&&e.blackLevel.length===4&&(n.userBlack=0,n.userCblack=e.blackLevel.map(o=>{const r=Math.round(o);return r===0?1:r})),e.demosaicMethod===-1?n.noInterpolation=!0:n.userQual=e.demosaicMethod,a?(n.outputColor=0,n.gamma=[1,1],n.userMul=[1,1,1,1],n.useCameraWb=!1):(n.outputColor=1,n.useCameraWb=!0),await t.open(l,n);const f=await t.imageData(),M=new ImageData(f.width,f.height),w=M.data,c=new Uint16Array(f.data.buffer,f.data.byteOffset,f.data.byteLength/2);if(a&&i.length===9){const o=i,y=Math.pow(2,e.exposure)*.25;for(let h=0;h<c.length;h+=3){const v=c[h]/65535,R=c[h+1]/65535,d=c[h+2]/65535;let x=o[0]*v+o[1]*R+o[2]*d,m=o[3]*v+o[4]*R+o[5]*d,b=o[6]*v+o[7]*R+o[8]*d;x*=y,m*=y,b*=y,x=Math.max(0,Math.min(1,x)),m=Math.max(0,Math.min(1,m)),b=Math.max(0,Math.min(1,b)),x=g(x),m=g(m),b=g(b);const p=h/3*4;w[p]=Math.round(x*255),w[p+1]=Math.round(m*255),w[p+2]=Math.round(b*255),w[p+3]=255}}else for(let o=0;o<c.length;o+=3){const r=o/3*4;w[r]=c[o]>>8,w[r+1]=c[o+1]>>8,w[r+2]=c[o+2]>>8,w[r+3]=255}return M}finally{t.delete?t.delete():t.close()}}async function S(u,e){const s=await G(),t=new s;try{await t.open(new Uint8Array(u));let l=16383;try{const r=await t.metadata(!0);r&&r.white_level&&(l=r.white_level)}catch{console.warn("Could not read metadata for white level, using default 16383")}const a=t.getRawImage(),i=a.width,n=a.height,f=a.data,M=new ImageData(i,n),w=M.data,c=e.blackLevel||[0,0,0,0],o=l;for(let r=0;r<n;r++){const y=r%2;for(let h=0;h<i;h++){const v=h%2,R=y*2+v,d=f[r*i+h],x=c[R];let m=(d-x)/(o-x);m=Math.max(0,Math.min(1,m)),e.exposure!==0&&(m*=Math.pow(2,e.exposure),m=Math.min(1,m));let b=0;m<=.0031308?b=12.92*m:b=1.055*Math.pow(m,1/2.4)-.055;const p=Math.round(b*255),C=(r*i+h)*4;w[C]=p,w[C+1]=p,w[C+2]=p,w[C+3]=255}}return M}finally{t.delete?t.delete():t.close()}}self.onmessage=async u=>{const{buffer:e,settings:s}=u.data;try{let t;s.renderMode==="zero-dependency"?t=await S(e,s):t=await J(e,s),self.postMessage({success:!0,imageData:t},[t.data.buffer])}catch(t){self.postMessage({success:!1,error:t.message})}};
